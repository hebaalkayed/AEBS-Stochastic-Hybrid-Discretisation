from dataclasses import dataclass, field
from typing import Dict, Tuple, List, Optional
import os

# Type Aliases for clarity
StateID = int
ActionName = str

@dataclass
class Transition:
    """
    Represents a probabilistic jump to a target state.
    For IMDPs (Interval MDPs), we store the probability bounds.
    """
    target_id: StateID
    p_min: float
    p_max: float

    @property
    def p_mean(self) -> float:
        """Returns the average probability (used for standard MDP export)."""
        return (self.p_min + self.p_max) / 2.0

@dataclass
class MDPState:
    """Optional metadata for a state (e.g., continuous center, safety label)."""
    id: StateID
    label: str = "safe"
    continuous_center: Optional[Tuple[float, ...]] = None

@dataclass
class MDP:
    """
    The mathematical artifact produced by Algorithm 1.
    Represents a Finite Interval Markov Decision Process.
    """
    num_states: int
    
    # Adjacency Map: (source_id, action) -> List of Transitions
    transitions: Dict[Tuple[StateID, ActionName], List[Transition]] = field(default_factory=dict)
    
    # Metadata: StateID -> State Info (useful for debugging/plotting)
    states: Dict[StateID, MDPState] = field(default_factory=dict)
    
    # NEW: Container for the PRISM text of the Controller (to be appended at export)
    controller_logic: str = ""

    def add_transition(self, src: StateID, action: ActionName, target: StateID, p_min: float, p_max: float):
        """Adds a transition to the MDP graph."""
        key = (src, action)
        if key not in self.transitions:
            self.transitions[key] = []
        
        # Check if target already exists to avoid duplicates
        self.transitions[key].append(Transition(target, p_min, p_max))

    def register_state(self, state_id: StateID, label: str = "safe", center=None):
        """Records metadata about a state."""
        self.states[state_id] = MDPState(state_id, label, center)

    def to_prism(self, filename: str):
        """
        Helper: Serializes this in-memory MDP to a PRISM .prism file.
        
        Changes from original:
        1. Renamed module to 'Plant'.
        2. Appends 'controller_logic' at the end of the file.
        """
        print(f"Exporting MDP ({self.num_states} states) to PRISM: {filename}...")
        
        with open(filename, 'w') as f:
            f.write("// Generated by AEBS Abstraction Layer\n")
            f.write("// Type: Finite Interval MDP (Exported as standard MDP with mean probabilities)\n")
            f.write("mdp\n\n")
            
            # --- MODULE 1: THE PLANT (Physics) ---
            f.write("module Plant\n")
            
            # 1. State Variable
            f.write(f"    s : [0..{self.num_states - 1}] init 0;\n\n")
            
            # 2. Transitions
            # Format: [action] s=id -> p1 : (s'=t1) + p2 : (s'=t2);
            count = 0
            for (src_id, action), targets in self.transitions.items():
                if not targets:
                    continue
                
                # PRISM syntax construction
                updates = []
                for t in targets:
                    # Using Mean Probability for standard MDP solvers
                    updates.append(f"{t.p_mean:.6f} : (s'={t.target_id})")
                
                line = f"    [{action}] s={src_id} -> " + " + ".join(updates) + ";\n"
                f.write(line)
                count += 1
                
            f.write("endmodule\n\n")
            
            # --- MODULE 2: THE CONTROLLER (Logic) ---
            if self.controller_logic:
                f.write(self.controller_logic)
            
        print(f"Successfully wrote {count} transitions to {filename}.")

    def get_stats(self):
        """Returns a summary string of the MDP."""
        n_trans = sum(len(t) for t in self.transitions.values())
        return f"MDP(States={self.num_states}, Transitions={n_trans}, Actions={len(set(k[1] for k in self.transitions.keys()))})"